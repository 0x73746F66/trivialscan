# Classes

See [Getting Started](./docs/1.getting-started.md) for a simply use example

## LeafCertValidator

The main class for this module

### __init__()

Manages state of the entire TLS assessment

### LeafCertValidator.mount(transport)

Passing a transport instance to the validator, this will not make a TLS request or prepare the certificates for proceeding method calls.

**Return**: `None`

```py
from tlsverify.validator import LeafCertValidator
from tlsverify.transport import Transport

transport = Transport('google.com')
transport.connect_least_secure()
validator = LeafCertValidator()
validator.mount(transport)
```

### Validator.init_der(der)

Given the provided DER encoded sequence of bytes, produce a PEM encoded sequence of bytes, `OpenSSL.crypto.X509` object, and an `cryptography.x509.Certificate` object

**Argument** `der` is an encoded X.509 certificate

**Required**: `True`

**Default**: `None`

**Type**: `bytes`

**Return**: `None`

```py
import os
from pathlib import Path
from tlsverify import Validator

der = Path(os.path.join(os.path.dirname(__file__), "cert.der")).read_bytes()
validator = Validator()
validator.init_der(der)
```

### Validator.init_pem(pem)

Given the provided PEM encoded sequence of bytes, produce a DER encoded sequence of bytes, `OpenSSL.crypto.X509` object, and an `cryptography.x509.Certificate` object

**Argument** `pem` is an encoded X.509 certificate

**Required**: `True`

**Default**: `None`

**Type**: `bytes`

**Return**: `None`

```py
import os
from pathlib import Path
from tlsverify import Validator

pem = Path(os.path.join(os.path.dirname(__file__), "cert.pem")).read_bytes()
validator = Validator()
validator.init_pem(pem)
```

### Validator.init_x509(x509)

Given the provided pyOpenSSL certificate object, produce a PEM encoded sequence of bytes, DER encoded sequence of bytes, and an `cryptography.x509.Certificate` object

**Argument** `x509` is a python object X509 from `pyOpenSSL`

**Required**: `True`

**Default**: `None`

**Type**: `OpenSSL.crypto.X509`

**Return**: `None`

```py
from tlsverify import Validator
from OpenSSL.crypto import X509

cert = X509()
validator = Validator()
validator.init_x509(cert)
```

### Validator.cert_to_text

Take no arguments and will produce text of the loaded certificate resembling OpenSSL command-line utility.

**Return**: `str`

### Validator.extract_x509_metadata

Take no arguments or provided no return value. This will process the loaded certificate and store any data extracted from this as properties of the `Metadata` instance. You can read the `Metadata` properties using:

**Return**: `None`

```py
from dataclasses import asdict
from tlsverify import Validator

validator = Validator()
# make sure you first initialize a certificate
validator.extract_x509_metadata(x509)
print(asdict(validator.metadata))
```

### Validator.extract_transport_metadata

Take no arguments or provided no return value. This will process the loaded Transport instance and store any data extracted from this as properties of the `Metadata` instance. You can read the `Metadata` properties using:

**Return**: `None`

```py
from dataclasses import asdict
from tlsverify import LeafCertValidator

validator = LeafCertValidator()
# make sure you first mount a Transport instance
validator.extract_transport_metadata(Transport('google.com'))
print(asdict(validator.metadata))
```

### Validator.parse_openssl_errors(errors)

Takes OpenSSL error number integers, and enriches the Validator state with this external information.

**Argument** `errors` A list of tuples. the first value is an `OpenSSL.crypto.X509` object, the second an `int` representing the OpenSSL error number.

**Required**: `True`

**Default**: `None`

**Type**: `list` of `tuple`, first value `OpenSSL.crypto.X509` second `int`

**Return**: `None`

### Validator.verify()

Given a `Transport` was mounted and a Certificate provided, this performs TLS validation.

**Return**: `bool`

```py
from tlsverify import LeafCertValidator

validator = LeafCertValidator()
# init_x509(cert)
# mount(Transport)
assert validator.verify()
```

### Validator.verify_chain()

This is a convenience method which is a wrapper to `util.validate_certificate_chain` that will additionally check for `basicConstraints`, any exceptions raised will be kept in the `Validator` state for reporting.

**Return**: `bool`

```py
from tlsverify import LeafCertValidator

validator = LeafCertValidator(host)
# init_x509(cert)
# mount(Transport)
assert validator.verify_chain()
```

## Metadata

No methods, properties are all public.

See built-in python `dataclasses` for more information about this class.

## Transport

(method) __init__: (self: Transport, host: str, port: int = 443) -> None

(method) pre_client_authentication_check: (self: Transport, client_pem_path: str | None = None, updater: tuple[Progress, TaskID] | None = None) -> bool

(method) do_request: (self: Transport, conn: Connection, method: str = 'HEAD', uri_path: str = '/', protocol: str = 'HTTP/1.1', request_compression: bool = True) -> (tuple[str, None] | tuple[str, str])

(method) prepare_context: (self: Transport, method: str | None = None, verify_mode: str | None = None, check_hostname: bool = False) -> Context

(method) prepare_connection: (self: Transport, context: Context) -> Connection

(static method) decode_http2_frame: (frame_data) -> Frame

(method) test_http2: (self: Transport, uri_path: str = '/', response_wait: int = 3) -> None

(method) connect: (self: Transport, tls_version: int, use_sni: bool = False, protocol: str | None = None) -> None

(method) connect_least_secure: (self: Transport, cafiles: list | None = None, use_sni: bool = False, updater: tuple[Progress, TaskID] | None = None) -> bool

(static method) is_connection_closed: (conn: Connection) -> bool

(static method) parse_header: (head: str) -> dict
